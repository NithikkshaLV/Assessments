# -*- coding: utf-8 -*-
"""LVADSUSR171_NITHIKKSHA_Clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19o0IWQCtQ2Uz6kMAhK-r-hdarGWdyfMg
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.cluster.hierarchy import fcluster
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler,LabelEncoder
le=LabelEncoder()
from sklearn.cluster import KMeans
from sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix, classification_report,f1_score
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from imblearn.over_sampling import SMOTE

import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv("/content/customer_segmentation.csv")
df.head(10)

df.shape

df.describe(include='all')

df.info()

df.columns

df.isnull().sum()

df.Income =df.Income.fillna(df.Income.median())
#df.fillna(df.median(),inplace=True)

df.isnull().sum()

#Correlation Matrix
num = df.select_dtypes(include=['float64','int64']).columns
correlation_matrix = df[num].corr()
print(correlation_matrix)

plt.figure(figsize=(14, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm')
plt.title('Heatmap of Correlation Matrix')
plt.show()

print(df.select_dtypes(include = ['int64','float64']).corr())

df.duplicated().sum()

df.info()

df.dtypes

df.Education = le.fit_transform(df.Education)
df.Marital_Status = le.fit_transform(df.Marital_Status)

#Outlier boxplot
# Identify numerical columns by data type
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Create a box plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))  # Set the figure size for better readability
    sns.boxplot(x=df[column])
    plt.title(f'Box Plot of {column}')
    plt.xlabel(column)
    plt.show()

df.columns

df.head()

df.Education.value_counts()

km = KMeans(n_clusters=3)
y_predicted = km.fit_predict(df[['Education','Income']])
print(y_predicted)

df['cluster']=y_predicted
print(df.head())

print(km.cluster_centers_)


df1 = df[df.cluster==0]
df2 = df[df.cluster==1]
df3 = df[df.cluster==2]
plt.scatter(df1['Education'],df1['Income'],color='green')
plt.scatter(df2['Education'],df2['Income'],color='red')
plt.scatter(df3['Education'],df3['Income'],color='black')

plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')
plt.xlabel('Education')
plt.ylabel('Income')
plt.legend()

sse = [] # The sum of Squared Errors =SSE
k_rng = range(1,10)
for k in k_rng:
   km = KMeans(n_clusters=k)
   km.fit(df[['Education','Income']])
   sse.append(km.inertia_)

plt.xlabel('K')
plt.ylabel('Sum of squared error')
plt.plot(k_rng,sse)

km = KMeans(n_clusters=3)
y_predicted = km.fit_predict(df[['Education','Income']])
print(y_predicted)

df['cluster']=y_predicted
print(df.head())

##
## km.cluster_centers_
## Returns a two-dimensional Numpy array which consists of coordinates of centres for the three clusters
##
print(km.cluster_centers_)


df1 = df[df.cluster==0]
df2 = df[df.cluster==1]
df3 = df[df.cluster==2]
plt.scatter(df1['Education'],df1['Income'],color='green')
plt.scatter(df2['Education'],df2['Income'],color='red')
plt.scatter(df3['Education'],df3['Income'],color='black')

plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')
plt.xlabel('Education')
plt.ylabel('Income')
plt.legend()

print(silhouette_score(df[['Education','Income']],y_predicted))

